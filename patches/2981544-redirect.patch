diff --git a/redirect.module b/redirect.module
index 74bc490..8c7d4f6 100644
--- a/redirect.module
+++ b/redirect.module
@@ -14,6 +14,9 @@ use Drupal\path_alias\PathAliasInterface;
 use Drupal\redirect\Entity\Redirect;
 use Symfony\Component\Routing\Exception\MissingMandatoryParametersException;
 use Symfony\Component\Routing\Exception\RouteNotFoundException;
+use Drupal\views\Views;
+use Drupal\views\ViewExecutable;
+use Drupal\views\Plugin\views\query\QueryPluginBase;
 
 /**
  * Implements hook_hook_info().
@@ -204,17 +207,17 @@ function redirect_delete_by_path($path, $langcode = NULL, $match_subpaths_and_re
 }
 
 /**
- * Sort an array recusively.
+ * Sort an array recursively.
  *
- * @param $array
+ * @param array $array
  *   The array to sort, by reference.
- * @param $callback
+ * @param string $callback
  *   The sorting callback to use (e.g. 'sort', 'ksort', 'asort').
  *
  * @return bool
  *   TRUE on success or FALSE on failure.
  */
-function redirect_sort_recursive(&$array, $callback = 'sort') {
+function redirect_sort_recursive(array &$array, $callback = 'sort') {
   $result = $callback($array);
   foreach ($array as $key => $value) {
     if (is_array($value)) {
@@ -224,6 +227,12 @@ function redirect_sort_recursive(&$array, $callback = 'sort') {
   return $result;
 }
 
+/**
+ * $code contains the selected status_code.
+ *
+ * @param $code
+ *   Status code
+ */
 function redirect_status_code_options($code = NULL) {
   $codes = [
     300 => t('300 Multiple Choices'),
@@ -240,8 +249,6 @@ function redirect_status_code_options($code = NULL) {
 /**
  * Returns if the current page request is a page not found (404 status error).
  *
- * Why the fuck do we have to do this? Why is there not an easier way???
- *
  * @return bool
  *   TRUE if the current page is a 404, or FALSE otherwise.
  */
@@ -250,9 +257,7 @@ function redirect_is_current_page_404() {
 }
 
 /**
- * Implements hook_form_FORM_ID_alter().
- *
- * (on behalf of locale.module)
+ * Implements hook_form_FORM_ID_alter() for locale.module.
  */
 function locale_form_redirect_edit_form_alter(array &$form, FormStateInterface $form_state) {
   $form['language'] = [
@@ -382,3 +387,95 @@ function redirect_form_node_form_alter(&$form, FormStateInterface $form_state, $
     ];
   }
 }
+
+/**
+ * Implements hook_views_query_alter().
+ */
+function redirect_views_query_alter(ViewExecutable $view, QueryPluginBase $query) {
+  if ($view->id() == "redirect" && redirect_is_query_alter_required_and_trim_source_path($query)) {
+    redirect_add_left_join_to_path_alias_table($query);
+    redirect_alter_where_clause($query);
+  }
+}
+
+/**
+ * Tests if the query needs to be altered and trim the source_path field.
+ */
+function redirect_is_query_alter_required_and_trim_source_path(QueryPluginBase &$query) {
+  $is_alter_required = FALSE;
+
+  foreach ($query->where as &$condition_group) {
+    foreach ($condition_group['conditions'] as &$condition) {
+      if ($condition['field'] == 'redirect.redirect_redirect__uri') {
+        $is_alter_required = TRUE;
+      }
+      elseif ($condition['field'] === 'redirect.redirect_source__path') {
+        $condition['value'] = "%" . trim($condition['value'], " \/\t\n\r\0\x0B%") . "%";
+      }
+    }
+  }
+
+  return $is_alter_required;
+}
+
+/**
+ * Add Left Join to path_alias table.
+ */
+function redirect_add_left_join_to_path_alias_table(QueryPluginBase &$query) {
+  $configuration = [
+    'type' => 'LEFT',
+    'table' => 'path_alias',
+    'field' => 'path',
+    'left_table' => 'redirect',
+    'left_field' => '',
+    'left_formula' => "replace(replace(redirect_redirect__uri,'entity:','/'),'internal:','')",
+    'operator' => '=',
+  ];
+
+  $join_obj = Views::pluginManager('join')->createInstance('standard', $configuration);
+  $rel = $query->addRelationship('path_alias_join', $join_obj, 'node_field_data');
+  $query->addTable('redirect', $rel, $join_obj, 'path_alias_join');
+}
+
+/**
+ * Alter the query where clause to include path_alias.alias field.
+ *
+ * Also includes internal and entity values in redirect.redirect_redirect__uri.
+ */
+function redirect_alter_where_clause(QueryPluginBase &$query) {
+  // Traverse through the 'where' part of the query.
+  $conditionValue = '';
+  foreach ($query->where as $key_group_conditions => &$condition_group) {
+    $conditions = $condition_group['conditions'];
+    foreach ($conditions as $key_cond => &$condition) {
+      if ($condition['field'] == 'redirect.redirect_redirect__uri') {
+        $conditionValue = $condition['value'];
+        // Remove the existing To field condition from the where clause.
+        unset($query->where[$key_group_conditions]['conditions'][$key_cond]);
+      }
+    }
+  }
+
+  if ($conditionValue != '') {
+    // html/core/modules/views/src/Plugin/views/query/Sql.php does not handle
+    // condition objects when using an operator or type formula. Therefore it
+    // was necessary to explicitly create the remainder of the where clause
+    // inside a string before passing it to Sql.php.
+    $where_addition = '';
+    // Condition for path_alias table.
+    $where_addition = $where_addition . '"path_alias_join"."alias" LIKE \'' . $conditionValue . '\'';
+    // Conditions for redirect table internal destinations.
+    $where_addition = $where_addition . ' OR "redirect"."redirect_redirect__uri" LIKE \'internal:' . $conditionValue . '\'';
+    $where_addition = $where_addition . ' OR "redirect"."redirect_redirect__uri" LIKE \'entity:' . $conditionValue . '\'';
+    // Condition for redirect table external destinations.
+    $where_addition = $where_addition . ' OR "redirect"."redirect_redirect__uri" LIKE \'http' . $conditionValue . '\'';
+
+    // Increment the key_cond to add another element to this array.
+    $next_key_cond = $key_cond + 1;
+    $query->where[$key_group_conditions]['conditions'][$next_key_cond] = [
+      'field' => $where_addition,
+      'value' => [],
+      'operator' => 'formula',
+    ];
+  }
+}
