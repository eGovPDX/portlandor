<?php

use Drupal\group\GroupMembershipLoaderInterface;
use Drupal\group\Entity\GroupInterface;
use Drupal\group\Entity\GroupTypeInterface;
use Drupal\group\Entity\GroupContentTypeInterface;
use Drupal\pathauto\Form\PathautoBulkUpdateForm;
use Drupal\Core\Render\BubbleableMetadata;
use Drupal\group\Entity\GroupContent;


// The plural is used in the list page URL. E.g. "/bds/guides"
// The group list view's path must match the plural form shown here.
// If the group list view doesn't exist, visiting the alias will get a 404.
const GROUP_CONTENT_TYPE_PLURAL = [
    "service" => "services",
    "guide" => "guides",
    "building" => "buildings",
    "city_service" => "services",
    "service_location" => "locations",
    "event" => "events",
    "image" => "images",
    "document" => "documents",
    "video" => "videos",
];

function createAliasForGroupContent($grp, $contentType, $lang) {
    // When a content type is not installed, $pluginType->getPluginDefinition()['entity_bundle'] returns false. Otherwise it's the string like "news".
    if($contentType === false) return;

    $contentTypePlural = (isset(GROUP_CONTENT_TYPE_PLURAL[$contentType]) ? GROUP_CONTENT_TYPE_PLURAL[$contentType] : $contentType);

    // Clean up shortname as it's from the editor
    $shortname = \Drupal::service("pathauto.alias_cleaner")
                ->cleanString($grp->get('field_shortname_or_acronym')->value);
    $alias = "/$shortname/$contentTypePlural";
    $gid = $grp->id();
    $system_path = "/group/$gid/$contentTypePlural";

    // If there is already an alias, skip it.
    $existing_alias = \Drupal::service('path.alias_storage')->lookupPathAlias($system_path, $lang);
    if ($existing_alias && $existing_alias == $alias) {
        return false;   
    }

    $path = \Drupal::service('path.alias_storage')->save($system_path, $alias, $lang);
    return true;
}

/**
 * Implements hook_ENTITY_TYPE_create().
 */
// When a content type is installed to a group type, create the alias for all groups with that group type.
function portland_group_content_type_create(GroupContentTypeInterface $groupContentType) {
    // Get all groups of this type. E.g. bureau_office
    $properties = ['type' => $groupContentType->getGroupTypeId()];
    $grps = \Drupal::entityTypeManager()
        ->getStorage('group')
        ->loadByProperties($properties);

    // Get the content type from content_plugin ID. E.g. "group_node:news"
    $contentTypePlugin = $groupContentType->getContentPluginId();
    
    if(strpos($contentTypePlugin, 'group_node:') === 0) {
        $contentType = substr($contentTypePlugin, strlen('group_node:'));
    } else if( strpos($contentTypePlugin, 'group_media:') === 0) {
        $contentType = substr($contentTypePlugin, strlen('group_media:'));
    } else {
        return;
    }

    // For each group, generate a new URL alias "group.field_shortname_or_acronym/contents"
    $lang = \Drupal::languageManager()->getCurrentLanguage()->getId();
    foreach ($grps as $grp) {
        createAliasForGroupContent($grp, $contentType, $lang);
    }    
}
/**
 * Implements hook_ENTITY_TYPE_delete().
 */
// When a content type is uninstaled from a group type, delete the alias added during creation time.
function portland_group_content_type_delete(GroupContentTypeInterface $groupContentType) {
    // Get all groups of this type
    $properties = ['type' => $groupContentType->getGroupTypeId()];
    $grps = \Drupal::entityTypeManager()
        ->getStorage('group')
        ->loadByProperties($properties);
    $lang = \Drupal::languageManager()->getCurrentLanguage()->getId();
    // content_plugin:"group_node:news"
    $contentTypePlugin = $groupContentType->getContentPluginId();
    if(strpos($contentTypePlugin, 'group_node:') === 0) {
        $contentType = substr($contentTypePlugin, strlen('group_node:'));
    } else if( strpos($contentTypePlugin, 'group_media:') === 0) {
        $contentType = substr($contentTypePlugin, strlen('group_media:'));
    } else {
        return;
    }

    // For each group, delete the URL alias "/group.field_shortname_or_acronym/contents". E.g. "/bds/news"
    $contentTypePlural = isset(GROUP_CONTENT_TYPE_PLURAL[$contentType]) ? GROUP_CONTENT_TYPE_PLURAL[$contentType] : $contentType;
    foreach ($grps as $grp) {
        $gid = $grp->id();
        $system_path = "/group/$gid/$contentTypePlural";

        // If found an alias, delete it.
        $existing_alias = \Drupal::service('path.alias_storage')
            ->lookupPathAlias($system_path, $lang);
        if($existing_alias) {
            $path = \Drupal::service('path.alias_storage')
                ->delete(['alias' => $existing_alias, 'langcode' => $lang]);
        }
    }  
}


/**
 * Implements hook_ENTITY_TYPE_insert().
 */
function portland_group_insert(GroupInterface $group) {
    // Find all installed content types on this group type and generate alias if it's missing.
    $installedContentTypes = $group->getGroupType()->getInstalledContentPlugins();
    $lang = \Drupal::languageManager()->getCurrentLanguage()->getId();
    foreach ($installedContentTypes as $pluginType) {
        $contentType = $pluginType->getPluginDefinition()['entity_bundle'];
        createAliasForGroupContent($group, $contentType, $lang);
    }

    // Workaround for Drupal bug: https://www.drupal.org/project/inline_entity_form/issues/2966933
    $group->path->pathauto = Drupal\pathauto\PathautoState::CREATE;

    // <TODO:>LOW PRIORITY: Generate URL aliases for group action links using group shortname (ie. /bds/content, /bds/members)</TODO:>
}
  
/**
 * Implements hook_ENTITY_TYPE_update().
 */
function portland_group_update(GroupInterface $group) {

    // 4.2. Bulk regenerate URL aliases for content by running pathauto batch processing
    $batch = array(
        'title' => t('Bulk updating URL aliases'),
        'operations' => array(
          array('Drupal\pathauto\Form\PathautoBulkUpdateForm::batchStart', array()),
        ),
        'finished' => 'Drupal\pathauto\Form\PathautoBulkUpdateForm::batchFinished',
    );
    $batch['operations'][] = array('Drupal\pathauto\Form\PathautoBulkUpdateForm::batchProcess', ["canonical_entities:node", "update"]);
    $batch['operations'][] = array('Drupal\pathauto\Form\PathautoBulkUpdateForm::batchProcess', ["canonical_entities:group", "update"]);
    $batch['operations'][] = array('Drupal\pathauto\Form\PathautoBulkUpdateForm::batchProcess', ["canonical_entities:group_content", "update"]);
    batch_set($batch);

    // get goup shortname and build paths
    $gid = $group->id();
    $shortname = \Drupal::service("pathauto.alias_cleaner")->cleanString($group->get('field_shortname_or_acronym')->value);
    $lang = \Drupal::languageManager()->getCurrentLanguage()->getId();

    // TODO: manually regenerate URL alias for main group page; pathauto bulk update isn't getting it sometimes
    $existing_alias = \Drupal::service('path.alias_storage')->lookupPathAlias("/group/$gid", $lang);
    $alias = "/$shortname";
    // if it exists and doesn't match current alias, delete and re-save
    if ($existing_alias && $existing_alias != $alias) {
        \Drupal::service('path.alias_storage')->delete(['alias' => $existing_alias, 'langcode' => $lang]);
        $path = \Drupal::service('path.alias_storage')->save("/group/$gid", $alias, $lang);
    }
    
    // POWR-142: Regenerate URL aliases for content type subpages using group shortname (ie. /bds/services)
    // reference: https://api.drupal.org/api/drupal/core%21lib%21Drupal%21Core%21Path%21AliasStorage.php/class/AliasStorage/8.6.x
    // Find all installed content types on this group type and generate alias if it's missing.
    $installedContentTypes = $group->getGroupType()->getInstalledContentPlugins();
    foreach ($installedContentTypes as $pluginType) {
        $contentType = $pluginType->getPluginDefinition()['entity_bundle'];
        // Skip if the content type is not installed with the group type.
        if($contentType === false) return;
        $contentTypePlural = isset(GROUP_CONTENT_TYPE_PLURAL[$contentType]) ? GROUP_CONTENT_TYPE_PLURAL[$contentType] : $contentType;
        $system_path = "/group/$gid/$contentTypePlural";
        $alias = "/$shortname/$contentTypePlural";

        $existing_alias = \Drupal::service('path.alias_storage')->lookupPathAlias($system_path, $lang);

        // if it already exists and matches, do nothing
        if ($existing_alias && $existing_alias == $alias) continue;

        // if it exists and doesn't match current alias, delete in preparation for re-save
        if ($existing_alias && $existing_alias != $alias) {
            \Drupal::service('path.alias_storage')->delete(['alias' => $existing_alias, 'langcode' => $lang]);
        }

        // save new or updated alias
        $path = \Drupal::service('path.alias_storage')->save($system_path, $alias, $lang);
    }

    // <TODO:>LOW PRIORITY: rEGenerate URL aliases for group action links using group shortname (ie. /bds/content, /bds/members)</TODO:>
}

/**
 * Implements hook_preprocess_views_view_field().
 */
function portland_preprocess_views_view_field(&$vars) {
    $view = $vars['view'];
    $field = $vars['field'];
    if ($view->id() == "alerts" && $view->current_display == 'block_1') {
        // Add the close button for each alert row.
        if($field->field == 'title') {
            $vars['output'] = Drupal\Core\Render\Markup::create($vars['output'].'<button type="button" class="close" aria-label="Close"><span aria-hidden="true">Ã—</span></button>');
        }
    }
}

function portland_preprocess_block(&$vars) {
    if ($vars['plugin_id'] == 'views_block:alerts-block_1') {
      $vars['#attached']['library'][] = 'portland/portland-alerts';
    }
}


/**
 * Implements hook_preprocess_views_view_unformatted().
 */
function portland_preprocess_views_view_unformatted(&$vars) {
    $view = $vars['view'];
    $rows = $vars['rows'];
    if ($view->id() == 'alerts') {
        // Map severity keys to Bootstrap class
        $severity_style = [
            '10' => 'danger',
            '20' => 'warning',
            '30' => 'info',
        ];
        foreach ($rows as $id => $row) {
            // Add the alert class for each row.
            $vars['rows'][$id]['attributes']->addClass([
                "portland-alert", 
                "alert", 
                "alert-".$severity_style[$view->result[$id]->_entity->field_severity->value]
            ]);
            // Set each alert's changed date/time in drupalSettings 
            $nid = $view->result[$id]->_entity->nid->value;
            $changed = $view->result[$id]->_entity->changed->value;
            $vars['#attached']['drupalSettings']['portland_alert'][$nid]['changed'] = $changed;
        }
    }
}

/*
 * Implements hook_entity_type_alter().
 */
function portland_entity_type_alter(array &$entity_types) {
    $node = $entity_types['node'];
    $node->addConstraint('EventDateTime', []);
}

/*
 * Implements hook_node_presave().
 */
function portland_node_presave($node) {
    if($node->bundle() == 'event') {
        // Clear start and end time for all-day events.
        if($node->field_all_day->value) {
            $node->set('field_start_time', NULL);
            $node->set('field_end_time', NULL);
        }
        // Clear the end date if it's the same as the start date.
        if(isset($node->field_end_date->value) &&
            $node->field_end_date->value == $node->field_start_date->value) {
            $node->set('field_end_date', NULL);
        }
    }
}

/**
 * Implements hook_token_info().
 */
function portland_token_info() {
    $tokens = [];
  
    $tokens['group'] = [
      'name' => t('Group'),
      'description' => t('The parent group.'),
      'type' => 'group',
    ];
  
    if (\Drupal::moduleHandler()->moduleExists('token')) {
      $tokens['groups'] = [
        'name' => t('Groups'),
        'description' => t("An array of all the node parent groups."),
        'type' => 'array',
      ];
    }
  
    return array(
      'tokens' => array('media' => $tokens),
    );
  }
  
  /**
   * Implements hook_tokens().
   */
  function portland_tokens($type, $tokens, array $data, array $options, BubbleableMetadata $bubbleable_metadata) {
    if ($type != 'media' || empty($data['media'])) {
      return [];
    }
  
    $token_service = \Drupal::token();
    $replacements = [];
  
    $group_content_array = GroupContent::loadByEntity($data['media']);
    if (empty($group_content_array)) {
      return [];
    }
  
    $groups = [];
    /** @var \Drupal\group\Entity\GroupContentInterface $group_content */
    foreach ($group_content_array as $group_content) {
      $group = $group_content->getGroup();
      $groups[$group->id()] = $group->label();
      $bubbleable_metadata->addCacheableDependency($group);
    };
  
    if (isset($tokens['groups'])) {
      $replacements[$tokens['groups']] = token_render_array($groups, $options);
    }
  
    // [media:groups:*] chained tokens.
    if ($parents_tokens = \Drupal::token()->findWithPrefix($tokens, 'groups')) {
      $replacements += \Drupal::token()->generate('array', $parents_tokens, array('array' => $groups), $options, $bubbleable_metadata);
    }
  
    /** @var \Drupal\group\Entity\GroupContentInterface $group_content */
    $group_content = array_pop($group_content_array);
    $group = $group_content->getGroup();
    if (isset($tokens['group'])) {
      $replacements[$tokens['group']] = $group->label();
    }
  
    if ($group_tokens = $token_service->findWithPrefix($tokens, 'group')) {
      $replacements += $token_service->generate('group', $group_tokens, array('group' => $group), $options, $bubbleable_metadata);
    }
  
    return $replacements;
  }
  